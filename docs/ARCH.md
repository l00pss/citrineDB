# CitrineDB Storage Engine Architecture

*Version: 0.1.0*  
*Last Updated: February 4, 2026*

This documentation provides a comprehensive explanation of CitrineDB's storage engine architecture and the relationships between its layers.

---

## 📐 Overall Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              APPLICATION LAYER                               │
│                    (SQL Queries, API Calls, CLI, Prepared Statements)        │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                               ENGINE LAYER                                   │
│                              engine/db.go                                    │
│    ┌──────────────────────────────────────────────────────────────────┐    │
│    │  Open() │ Execute() │ Query() │ Prepare() │ Close() │ Stats()   │    │
│    └──────────────────────────────────────────────────────────────────┘    │
│    ┌──────────────────────────────────────────────────────────────────┐    │
│    │                    PREPARED STATEMENTS                            │    │
│    │        engine/prepared.go - SQL Injection Prevention              │    │
│    │     Positional (?) │ Numbered ($1,$2) │ Parameter Binding         │    │
│    └──────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                             QUERY PROCESSOR                                  │
│    ┌─────────────────────────────────────────────────────────────────┐     │
│    │   citrinelexer        planner/           executor/              │     │
│    │   ┌─────────┐       ┌─────────┐        ┌─────────────────┐     │     │
│    │   │ Lexer   │──────▶│ Planner │───────▶│    Executor     │     │     │
│    │   │ Parser  │       │         │        │                 │     │     │
│    │   └─────────┘       └─────────┘        └─────────────────┘     │     │
│    │                                                                 │     │
│    │   Supported: SELECT, INSERT, UPDATE, DELETE, CREATE, DROP      │     │
│    │              BEGIN, COMMIT, ROLLBACK, JOIN, Aggregates         │     │
│    └─────────────────────────────────────────────────────────────────┘     │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                    ┌─────────────────┼─────────────────┐
                    ▼                 ▼                 ▼
┌───────────────────────┐ ┌───────────────────┐ ┌───────────────────────────┐
│     TABLE LAYER       │ │    INDEX LAYER    │ │    TRANSACTION LAYER      │
│   storage/table/      │ │  storage/index/   │ │      storage/tx/          │
│  ┌─────────────────┐  │ │ ┌───────────────┐ │ │  ┌─────────────────────┐  │
│  │   Heap File     │  │ │ │   B+Tree      │ │ │  │    WAL Manager      │  │
│  │   Management    │  │ │ │   Index       │ │ │  │    (walrus)         │  │
│  └─────────────────┘  │ │ └───────────────┘ │ │  └─────────────────────┘  │
└───────────────────────┘ └───────────────────┘ └───────────────────────────┘
           │                       │                         │
           └───────────────────────┼─────────────────────────┘
                                   ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                             RECORD LAYER                                     │
│                           storage/record/                                    │
│    ┌──────────────────────────────────────────────────────────────────┐    │
│    │  Schema Definition │ Serialization │ Deserialization │ Types    │    │
│    └──────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                             CATALOG LAYER                                    │
│                           storage/catalog/                                   │
│    ┌──────────────────────────────────────────────────────────────────┐    │
│    │  Table Metadata │ Column Info │ Index Registry │ Schema Cache   │    │
│    └──────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                            BUFFER POOL LAYER                                 │
│                            storage/buffer/                                   │
│    ┌────────────────────────────────────────────────────────────────────┐  │
│    │                        BUFFER POOL                                  │  │
│    │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐      │  │
│    │  │ Frame 0 │ │ Frame 1 │ │ Frame 2 │ │ Frame 3 │ │  . . .  │      │  │
│    │  └─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘      │  │
│    │  ┌──────────────────────────────────────────────────────────────┐ │  │
│    │  │              LRU Replacement Policy                          │ │  │
│    │  └──────────────────────────────────────────────────────────────┘ │  │
│    └────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                              PAGE LAYER                                      │
│                             storage/page/                                    │
│    ┌────────────────────────────────────────────────────────────────────┐  │
│    │                      SLOTTED PAGE FORMAT                            │  │
│    │  ┌────────────────────────────────────────────────────────────┐   │  │
│    │  │ HEADER │ SLOT DIR │      FREE SPACE      │ RECORD DATA     │   │  │
│    │  │        │ →→→→→→→→ │                      │ ←←←←←←←←←←←←←← │   │  │
│    │  └────────────────────────────────────────────────────────────┘   │  │
│    └────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           DISK MANAGER LAYER                                 │
│                             storage/file/                                    │
│    ┌────────────────────────────────────────────────────────────────────┐  │
│    │  ReadPage() │ WritePage() │ AllocatePage() │ DeallocatePage()     │  │
│    └────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                              PHYSICAL DISK                                   │
│                    ┌────────────────────────────────────┐                   │
│                    │  database.db  │  *.wal  │  *.idx   │                   │
│                    └────────────────────────────────────┘                   │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 🔗 Inter-Layer Data Flow

### 1. Write Operation (INSERT) Flow

```
                              INSERT INTO users VALUES (1, 'Ali', 25)
                                              │
                                              ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 1: Transaction Layer (WAL)                                             │
│ ════════════════════════════════════════════════════════════════════════════│
│                                                                             │
│   ┌─────────────┐    ┌─────────────────────────────────────────────────┐   │
│   │ BEGIN TX    │───▶│ WAL Entry: LSN=1, Type=INSERT, Data=(1,Ali,25) │   │
│   │ TxID = 42   │    └─────────────────────────────────────────────────┘   │
│   └─────────────┘                        │                                  │
│                                          ▼                                  │
│                              ┌─────────────────────┐                       │
│                              │    wal.log file     │                       │
│                              │  (written to disk)  │                       │
│                              └─────────────────────┘                       │
└─────────────────────────────────────────────────────────────────────────────┘
                                              │
                                              ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 2: Record Layer                                                        │
│ ════════════════════════════════════════════════════════════════════════════│
│                                                                             │
│   Input: (1, 'Ali', 25)                                                     │
│                                                                             │
│   ┌───────────────────────────────────────────────────────────────────┐    │
│   │                        SERIALIZATION                               │    │
│   │                                                                    │    │
│   │   Field Count: 3                                                   │    │
│   │   Null Bitmap: 0b00000000 (no nulls)                              │    │
│   │                                                                    │    │
│   │   Field 0: TypeInt32  → [0x01, 0x00, 0x00, 0x00]  (4 bytes)       │    │
│   │   Field 1: TypeString → [0x03, 'A', 'l', 'i']     (1+3 bytes)     │    │
│   │   Field 2: TypeInt32  → [0x19, 0x00, 0x00, 0x00]  (4 bytes)       │    │
│   │                                                                    │    │
│   └───────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│   Output: []byte{0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 'A', 'l', 'i',  │
│                  0x19, 0x00, 0x00, 0x00}                                    │
└─────────────────────────────────────────────────────────────────────────────┘
                                              │
                                              ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 3: Table Layer (Heap File)                                             │
│ ════════════════════════════════════════════════════════════════════════════│
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                    FIND FREE PAGE ALGORITHM                          │  │
│   │                                                                      │  │
│   │   1. Check Free Page List                                           │  │
│   │      └─▶ Page 3 has sufficient space ✓                              │  │
│   │                                                                      │  │
│   │   2. Select Page 3                                                  │  │
│   │                                                                      │  │
│   │   3. Insert record                                                  │  │
│   │      └─▶ SlotID = 5 assigned                                        │  │
│   │                                                                      │  │
│   │   4. Create RID                                                     │  │
│   │      └─▶ RID = (PageID: 3, SlotID: 5)                               │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│   Return: RID(3, 5)                                                         │
└─────────────────────────────────────────────────────────────────────────────┘
                                              │
                                              ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 4: Index Layer (B+Tree)                                                │
│ ════════════════════════════════════════════════════════════════════════════│
│                                                                             │
│   Primary Key Index Update:                                                 │
│                                                                             │
│                           [50|100]                                          │
│                          /   |   \                                          │
│                         /    |    \                                         │
│                    [25] [75|90] [125]                                       │
│                    / \                                                      │
│                   /   \                                                     │
│              [1|10|20] [30|40]                                              │
│               ↑                                                             │
│               └── NEW: Key=1, Value=RID(3,5)                               │
│                                                                             │
│   INSERT: BTree.Insert(key=1, value=RID(3,5))                              │
└─────────────────────────────────────────────────────────────────────────────┘
                                              │
                                              ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 5: Buffer Pool Layer                                                   │
│ ════════════════════════════════════════════════════════════════════════════│
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                         BUFFER POOL STATE                            │  │
│   │                                                                      │  │
│   │   Frame 0: Page 1  │ dirty=N │ pin=0 │                              │  │
│   │   Frame 1: Page 3  │ dirty=Y │ pin=1 │ ◄── Modified!                │  │
│   │   Frame 2: Page 7  │ dirty=N │ pin=0 │                              │  │
│   │   Frame 3: Empty   │         │       │                              │  │
│   │                                                                      │  │
│   │   LRU List: [Page 3] → [Page 1] → [Page 7]                          │  │
│   │              ↑                                                       │  │
│   │              Most Recently Used                                      │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│   Actions:                                                                  │
│   1. FetchPage(3) - Load Page 3 into buffer (if exists, pin++)            │
│   2. MarkDirty(3) - Mark Page 3 as dirty                                  │
│   3. UnpinPage(3) - Decrement pin count when done                         │
└─────────────────────────────────────────────────────────────────────────────┘
                                              │
                                              ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 6: Page Layer                                                          │
│ ════════════════════════════════════════════════════════════════════════════│
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                     PAGE 3 - SLOTTED PAGE                            │  │
│   │                                                                      │  │
│   │   BEFORE INSERT:                                                     │  │
│   │   ┌────────┬───────────────┬──────────────┬────────────────────┐   │  │
│   │   │ Header │ Slot0..Slot4  │  Free Space  │ Rec4..Rec0         │   │  │
│   │   │ 10B    │ 5×4=20B       │    3000B     │ 1066B              │   │  │
│   │   └────────┴───────────────┴──────────────┴────────────────────┘   │  │
│   │                                                                      │  │
│   │   AFTER INSERT:                                                      │  │
│   │   ┌────────┬────────────────┬─────────────┬─────────────────────┐  │  │
│   │   │ Header │ Slot0..Slot5   │ Free Space  │ Rec5│Rec4..Rec0     │  │  │
│   │   │ 10B    │ 6×4=24B        │   2976B     │ 14B + 1066B         │  │  │
│   │   └────────┴────────────────┴─────────────┴─────────────────────┘  │  │
│   │                     ↑                        ↑                      │  │
│   │                     │                        └── New Record (14B)   │  │
│   │                     └── New Slot Entry                              │  │
│   │                                                                      │  │
│   │   Slot 5: { offset: 4082, size: 14 }                                │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
                                              │
                                              ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 7: Transaction Commit                                                  │
│ ════════════════════════════════════════════════════════════════════════════│
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                         COMMIT SEQUENCE                              │  │
│   │                                                                      │  │
│   │   1. Write COMMIT log to WAL                                        │  │
│   │      └─▶ WAL Entry: LSN=2, Type=COMMIT, TxID=42                     │  │
│   │                                                                      │  │
│   │   2. WAL sync (fsync)                                               │  │
│   │      └─▶ COMMIT record written to disk ✓                            │  │
│   │                                                                      │  │
│   │   3. Buffer Pool flush (lazy or immediate)                          │  │
│   │      └─▶ Dirty pages written to disk                                │  │
│   │                                                                      │  │
│   │   4. Transaction completed ✓                                        │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
                                              │
                                              ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 8: Disk Manager Layer                                                  │
│ ════════════════════════════════════════════════════════════════════════════│
│                                                                             │
│   WritePage(3, pageData)                                                    │
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                        DATABASE FILE                                 │  │
│   │                                                                      │  │
│   │   Offset = PageID × PageSize = 3 × 4096 = 12288                     │  │
│   │                                                                      │  │
│   │   ┌──────────────────────────────────────────────────────────────┐ │  │
│   │   │ Byte 0      │ Byte 4096   │ Byte 8192   │ Byte 12288  │ ... │ │  │
│   │   │ Page 0      │ Page 1      │ Page 2      │ Page 3      │     │ │  │
│   │   │             │             │             │ ◄── WRITE   │     │ │  │
│   │   └──────────────────────────────────────────────────────────────┘ │  │
│   │                                                                      │  │
│   │   file.WriteAt(pageData, 12288)                                     │  │
│   │   file.Sync()  // fsync - durability guarantee                      │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### 2. Read Operation (SELECT) Flow

```
                              SELECT * FROM users WHERE id = 1
                                              │
                                              ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 1: Index Lookup (B+Tree)                                               │
│ ════════════════════════════════════════════════════════════════════════════│
│                                                                             │
│   BTree.Search(key=1)                                                       │
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                      B+TREE TRAVERSAL                                │  │
│   │                                                                      │  │
│   │   Level 0 (Root):    [50|100]                                       │  │
│   │                         │                                            │  │
│   │                    1 < 50, go left                                   │  │
│   │                         │                                            │  │
│   │                         ▼                                            │  │
│   │   Level 1:           [25]                                            │  │
│   │                         │                                            │  │
│   │                    1 < 25, go left                                   │  │
│   │                         │                                            │  │
│   │                         ▼                                            │  │
│   │   Level 2 (Leaf): [1|10|20]                                         │  │
│   │                    ↑                                                 │  │
│   │                    FOUND! Value = RID(3, 5)                          │  │
│   │                                                                      │  │
│   │   Disk I/O: 3 page reads (or from buffer pool)                      │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│   Return: RID(PageID=3, SlotID=5)                                          │
└─────────────────────────────────────────────────────────────────────────────┘
                                              │
                                              ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 2: Buffer Pool Fetch                                                   │
│ ════════════════════════════════════════════════════════════════════════════│
│                                                                             │
│   FetchPage(3)                                                              │
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                      BUFFER POOL LOOKUP                              │  │
│   │                                                                      │  │
│   │   1. Search for Page 3 in Page Table                                │  │
│   │      ┌──────────────────────────────┐                               │  │
│   │      │ PageID │ FrameID │ Dirty│Pin │                               │  │
│   │      ├────────┼─────────┼──────┼────┤                               │  │
│   │      │   1    │    0    │  N   │ 0  │                               │  │
│   │      │   3    │    1    │  N   │ 0  │ ◄── FOUND!                    │  │
│   │      │   7    │    2    │  N   │ 0  │                               │  │
│   │      └──────────────────────────────┘                               │  │
│   │                                                                      │  │
│   │   2. Cache HIT! No disk read needed                                 │  │
│   │                                                                      │  │
│   │   3. Increment pin count: pin = 1                                   │  │
│   │                                                                      │  │
│   │   4. Move to front of LRU list                                      │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│   Return: Page 3 data                                                       │
└─────────────────────────────────────────────────────────────────────────────┘
                                              │
                                              ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 3: Page Layer - Get Record                                             │
│ ════════════════════════════════════════════════════════════════════════════│
│                                                                             │
│   GetRecord(slotID=5)                                                       │
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                      SLOT LOOKUP                                     │  │
│   │                                                                      │  │
│   │   Page 3 Memory Layout:                                              │  │
│   │   ┌──────────────────────────────────────────────────────────────┐ │  │
│   │   │ Header │ S0 │ S1 │ S2 │ S3 │ S4 │ S5 │ Free │ Data...       │ │  │
│   │   └──────────────────────────────────────────────────────────────┘ │  │
│   │                                    ↑                                │  │
│   │                            Slot 5: offset=4082, size=14             │  │
│   │                                    │                                │  │
│   │                                    ▼                                │  │
│   │   ┌──────────────────────────────────────────────────────────────┐ │  │
│   │   │ ... │ Free Space │ [14 bytes record data] │ older records   │ │  │
│   │   └──────────────────────────────────────────────────────────────┘ │  │
│   │                         ↑                                          │  │
│   │                         └── Extract bytes [4082:4096]              │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│   Return: []byte (serialized record)                                        │
└─────────────────────────────────────────────────────────────────────────────┘
                                              │
                                              ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 4: Record Layer - Deserialize                                          │
│ ════════════════════════════════════════════════════════════════════════════│
│                                                                             │
│   Deserialize(data, schema)                                                 │
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                      DESERIALIZATION                                 │  │
│   │                                                                      │  │
│   │   Input bytes: [0x03,0x00,0x01,0x00,0x00,0x00,0x03,'A','l','i',     │  │
│   │                 0x19,0x00,0x00,0x00]                                 │  │
│   │                                                                      │  │
│   │   Parse Header:                                                      │  │
│   │   - Field Count: 3                                                   │  │
│   │   - Null Bitmap: 0b00000000                                         │  │
│   │                                                                      │  │
│   │   Parse Fields:                                                      │  │
│   │   - Field 0 (Int32):  0x01000000 → 1                                │  │
│   │   - Field 1 (String): len=3, "Ali"                                  │  │
│   │   - Field 2 (Int32):  0x19000000 → 25                               │  │
│   │                                                                      │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│   Return: Record { id: 1, name: "Ali", age: 25 }                           │
└─────────────────────────────────────────────────────────────────────────────┘
                                              │
                                              ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 5: Cleanup                                                             │
│ ════════════════════════════════════════════════════════════════════════════│
│                                                                             │
│   UnpinPage(3)  // Decrement pin count in buffer pool                      │
│                                                                             │
│   Result: { id: 1, name: "Ali", age: 25 }                                   │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### 3. Full Table Scan (Index-less Search)

```
                              SELECT * FROM users WHERE age > 20
                                              │
                                              ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ HEAP FILE SCAN                                                              │
│ ════════════════════════════════════════════════════════════════════════════│
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                      SEQUENTIAL SCAN                                 │  │
│   │                                                                      │  │
│   │   for pageID := 1; pageID <= totalPages; pageID++ {                 │  │
│   │       page := bufferPool.FetchPage(pageID)                          │  │
│   │                                                                      │  │
│   │       for slotID := 0; slotID < page.SlotCount(); slotID++ {        │  │
│   │           record := page.GetRecord(slotID)                          │  │
│   │           if record.age > 20 {                                      │  │
│   │               results.Add(record)                                   │  │
│   │           }                                                          │  │
│   │       }                                                              │  │
│   │                                                                      │  │
│   │       bufferPool.UnpinPage(pageID)                                  │  │
│   │   }                                                                  │  │
│   │                                                                      │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│   Scan Pattern:                                                             │
│                                                                             │
│   Page 1 ──▶ Page 2 ──▶ Page 3 ──▶ Page 4 ──▶ ... ──▶ Page N             │
│     │          │          │          │                   │                 │
│     ▼          ▼          ▼          ▼                   ▼                 │
│   Check      Check      Check      Check               Check               │
│   Records    Records    Records    Records             Records             │
│                                                                             │
│   Complexity: O(N) where N = total records                                 │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 🔄 Buffer Pool - Page Replacement Scenario

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ SCENARIO: Buffer Pool Full, Need to Load New Page                           │
│ ════════════════════════════════════════════════════════════════════════════│
│                                                                             │
│ Initial State (4 frames, all occupied):                                     │
│                                                                             │
│   ┌─────────┬─────────┬─────────┬─────────┐                                │
│   │ Frame 0 │ Frame 1 │ Frame 2 │ Frame 3 │                                │
│   │ Page 1  │ Page 3  │ Page 7  │ Page 12 │                                │
│   │ pin=0   │ pin=2   │ pin=0   │ pin=0   │                                │
│   │ dirty=N │ dirty=Y │ dirty=N │ dirty=Y │                                │
│   └─────────┴─────────┴─────────┴─────────┘                                │
│                                                                             │
│   LRU Order: [Page 3] → [Page 12] → [Page 1] → [Page 7]                    │
│               newest                            oldest                      │
│                                                                             │
│ Request: FetchPage(20)                                                      │
│                                                                             │
│ ┌───────────────────────────────────────────────────────────────────────┐  │
│ │ LRU EVICTION ALGORITHM                                                 │  │
│ │                                                                        │  │
│ │ 1. Find victim (oldest unpinned page):                                │  │
│ │    - Page 7: pin=0 ✓ oldest unpinned                                  │  │
│ │    - Selected: Page 7 (Frame 2)                                       │  │
│ │                                                                        │  │
│ │ 2. Check if dirty:                                                    │  │
│ │    - Page 7: dirty=N                                                  │  │
│ │    - No flush needed ✓                                                │  │
│ │                                                                        │  │
│ │ 3. Evict Page 7:                                                      │  │
│ │    - Remove from page table                                           │  │
│ │    - Remove from LRU list                                             │  │
│ │                                                                        │  │
│ │ 4. Load Page 20:                                                      │  │
│ │    - DiskManager.ReadPage(20)                                         │  │
│ │    - Store in Frame 2                                                 │  │
│ │    - Add to page table                                                │  │
│ │    - Add to LRU list (front)                                          │  │
│ │    - Set pin=1                                                        │  │
│ └───────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│ Final State:                                                                │
│                                                                             │
│   ┌─────────┬─────────┬─────────┬─────────┐                                │
│   │ Frame 0 │ Frame 1 │ Frame 2 │ Frame 3 │                                │
│   │ Page 1  │ Page 3  │ Page 20 │ Page 12 │  ◄── Page 7 replaced          │
│   │ pin=0   │ pin=2   │ pin=1   │ pin=0   │                                │
│   │ dirty=N │ dirty=Y │ dirty=N │ dirty=Y │                                │
│   └─────────┴─────────┴─────────┴─────────┘                                │
│                                                                             │
│   LRU Order: [Page 20] → [Page 3] → [Page 12] → [Page 1]                   │
│               newest                             oldest                     │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 💾 WAL Recovery Scenario

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ CRASH RECOVERY SCENARIO                                                     │
│ ════════════════════════════════════════════════════════════════════════════│
│                                                                             │
│ Timeline before crash:                                                      │
│                                                                             │
│   T1: BEGIN TX 1                                                            │
│   T2: INSERT record A (TX 1)                                                │
│   T3: BEGIN TX 2                                                            │
│   T4: INSERT record B (TX 2)                                                │
│   T5: COMMIT TX 1            ← TX 1 committed                               │
│   T6: INSERT record C (TX 2)                                                │
│   T7: ──── CRASH ────        ← TX 2 not committed                           │
│                                                                             │
│ WAL Content:                                                                │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │ LSN │ Type    │ TxID │ Data                                         │  │
│   ├─────┼─────────┼──────┼──────────────────────────────────────────────┤  │
│   │ 1   │ BEGIN   │ 1    │                                              │  │
│   │ 2   │ INSERT  │ 1    │ Record A                                     │  │
│   │ 3   │ BEGIN   │ 2    │                                              │  │
│   │ 4   │ INSERT  │ 2    │ Record B                                     │  │
│   │ 5   │ COMMIT  │ 1    │                                              │  │
│   │ 6   │ INSERT  │ 2    │ Record C                                     │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│ Recovery Process:                                                           │
│                                                                             │
│   ┌───────────────────────────────────────────────────────────────────┐    │
│   │ PHASE 1: ANALYSIS                                                  │    │
│   │                                                                    │    │
│   │ Scan WAL forward:                                                  │    │
│   │ - TX 1: BEGIN at LSN 1, COMMIT at LSN 5 → COMMITTED               │    │
│   │ - TX 2: BEGIN at LSN 3, no COMMIT      → UNCOMMITTED              │    │
│   │                                                                    │    │
│   │ Committed Transactions: [TX 1]                                     │    │
│   │ Active Transactions:    [TX 2]                                     │    │
│   └───────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│   ┌───────────────────────────────────────────────────────────────────┐    │
│   │ PHASE 2: REDO (Committed transactions)                            │    │
│   │                                                                    │    │
│   │ Replay TX 1 operations:                                           │    │
│   │ - LSN 2: INSERT Record A → Apply to data file ✓                   │    │
│   │                                                                    │    │
│   │ Result: Record A is in database ✓                                 │    │
│   └───────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│   ┌───────────────────────────────────────────────────────────────────┐    │
│   │ PHASE 3: UNDO (Uncommitted transactions)                          │    │
│   │                                                                    │    │
│   │ Rollback TX 2 operations (reverse order):                         │    │
│   │ - LSN 6: INSERT Record C → Remove from data file ✓                │    │
│   │ - LSN 4: INSERT Record B → Remove from data file ✓                │    │
│   │                                                                    │    │
│   │ Result: Records B and C are NOT in database ✓                     │    │
│   └───────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│ Final Database State:                                                       │
│   - Record A: EXISTS (TX 1 was committed)                                  │
│   - Record B: NOT EXISTS (TX 2 was rolled back)                            │
│   - Record C: NOT EXISTS (TX 2 was rolled back)                            │
│                                                                             │
│ ACID Guarantees Maintained:                                                 │
│   ✓ Atomicity: TX 2 all-or-nothing (nothing)                               │
│   ✓ Durability: TX 1 changes survived crash                                │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 📊 Performance Characteristics

### Complexity Analysis

| Operation | With Index | Without Index | Description |
|-----------|------------|---------------|-------------|
| Point Query | O(log N) | O(N) | Single record lookup |
| Range Query | O(log N + K) | O(N) | K = result count |
| Insert | O(log N) | O(1) | Including index update |
| Delete | O(log N) | O(N) | Find + delete |
| Update | O(log N) | O(N) | Find + update |
| Full Scan | O(N) | O(N) | All records |

### I/O Comparison

```
1,000,000 records, Page Size = 4KB, 100 records/page

Point Query (id = 500000):
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  Without Index (Heap Scan):                                 │
│  ─────────────────────────                                  │
│  Pages to read: ~5000 (worst case)                          │
│  I/O Cost: 5000 × 4KB = 20MB                                │
│  Time (HDD): 5000 × 10ms = 50 seconds                       │
│                                                             │
│  With B+Tree Index:                                         │
│  ──────────────────                                         │
│  Tree depth: log₁₀₀(1,000,000) ≈ 3                          │
│  Pages to read: 3 (index) + 1 (data) = 4                    │
│  I/O Cost: 4 × 4KB = 16KB                                   │
│  Time (HDD): 4 × 10ms = 40 milliseconds                     │
│                                                             │
│  Speedup: 1250× faster with index!                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Buffer Pool Hit Rate Impact

```
Buffer Pool Size: 1000 pages (4MB)
Working Set: 500 pages (frequently accessed)

Scenario A: 80% hit rate
┌────────────────────────────────────────┐
│ 100 queries:                           │
│ - 80 from buffer (0.0001ms each)       │
│ - 20 from disk (10ms each)             │
│ Total: 80×0.0001 + 20×10 = 200.008ms   │
└────────────────────────────────────────┘

Scenario B: 99% hit rate
┌────────────────────────────────────────┐
│ 100 queries:                           │
│ - 99 from buffer (0.0001ms each)       │
│ - 1 from disk (10ms each)              │
│ Total: 99×0.0001 + 1×10 = 10.0099ms    │
└────────────────────────────────────────┘

Improvement: ~20× faster with better hit rate!
```

---

## 🏗️ Module Dependency Graph

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         MODULE DEPENDENCY GRAPH                              │
│ ════════════════════════════════════════════════════════════════════════════│
│                                                                             │
│                              ┌─────────────────┐                            │
│                              │  storage/table  │                            │
│                              │   (Heap File)   │                            │
│                              └────────┬────────┘                            │
│                                       │                                      │
│                         ┌─────────────┼─────────────┐                       │
│                         │             │             │                       │
│                         ▼             │             ▼                       │
│              ┌─────────────────┐      │     ┌─────────────────┐            │
│              │ storage/index   │      │     │   storage/tx    │            │
│              │   (B+Tree)      │      │     │     (WAL)       │            │
│              └────────┬────────┘      │     └────────┬────────┘            │
│                       │               │              │                      │
│                       │               ▼              │                      │
│                       │      ┌─────────────────┐     │                      │
│                       │      │ storage/record  │     │                      │
│                       │      │ (Serialization) │     │                      │
│                       │      └────────┬────────┘     │                      │
│                       │               │              │                      │
│                       └───────────────┼──────────────┘                      │
│                                       │                                      │
│                                       ▼                                      │
│                              ┌─────────────────┐                            │
│                              │ storage/buffer  │                            │
│                              │  (Buffer Pool)  │                            │
│                              └────────┬────────┘                            │
│                                       │                                      │
│                                       ▼                                      │
│                              ┌─────────────────┐                            │
│                              │  storage/page   │                            │
│                              │ (Slotted Page)  │                            │
│                              └────────┬────────┘                            │
│                                       │                                      │
│                                       ▼                                      │
│                              ┌─────────────────┐                            │
│                              │  storage/file   │                            │
│                              │ (Disk Manager)  │                            │
│                              └────────┬────────┘                            │
│                                       │                                      │
│                                       ▼                                      │
│                              ┌─────────────────┐                            │
│                              │   OS / Disk     │                            │
│                              └─────────────────┘                            │
│                                                                             │
│ External Dependencies:                                                       │
│   citrinelexer  v0.1.6 ─────▶ SQL Lexer/Parser                             │
│   walrus        v0.2.1 ─────▶ Write-Ahead Logging                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 📁 Project Structure

```
citrinedb/
├── cmd/
│   └── citrinedb/
│       └── main.go              # CLI entry point
│
├── engine/
│   ├── db.go                    # Database engine (Open, Execute, Query)
│   ├── prepared.go              # Prepared statements (SQL injection prevention)
│   └── prepared_test.go
│
├── executor/
│   └── executor.go              # SQL execution engine
│
├── planner/
│   └── planner.go               # Query planning
│
├── storage/
│   ├── buffer/
│   │   ├── buffer_pool.go       # Buffer pool management
│   │   └── lru.go               # LRU replacement policy
│   │
│   ├── catalog/
│   │   └── catalog.go           # Table/index metadata
│   │
│   ├── file/
│   │   └── disk_manager.go      # File I/O operations
│   │
│   ├── index/
│   │   ├── btree.go             # B+Tree index wrapper
│   │   └── errors.go
│   │
│   ├── page/
│   │   ├── page.go              # Slotted page implementation
│   │   └── iterator.go
│   │
│   ├── record/
│   │   └── record.go            # Record serialization
│   │
│   ├── table/
│   │   └── heap.go              # Heap file management
│   │
│   └── tx/
│       └── wal.go               # WAL manager wrapper
│
├── docs/
│   ├── architecture.md          # This documentation
│   ├── USER_GUIDE.md            # User guide
│   ├── slotted-page.md
│   └── storage-layers-deep-dive.md
│
├── examples/
│   └── test_all_features.sql    # SQL test suite
│
├── go.mod
└── README.md
```

---

## 🔧 Configuration

```go
type Config struct {
    Path           string  // Database file path (":memory:" for in-memory)
    PageSize       int     // Page size in bytes (default: 4096)
    BufferPoolSize int     // Number of pages in buffer pool (default: 1000)
    WALDir         string  // WAL directory
    SyncWrites     bool    // Sync after each write
}
```

---

## 🔍 Layer Responsibilities Summary

| Layer | Package | Responsibility |
|-------|---------|----------------|
| **Engine** | `engine/` | High-level API, prepared statements, connection management |
| **Executor** | `executor/` | SQL statement execution, JOIN processing, aggregations |
| **Planner** | `planner/` | Query planning and optimization |
| **Catalog** | `storage/catalog` | Table/index metadata management |
| **Table** | `storage/table` | Heap file organization |
| **Index** | `storage/index` | B+Tree index operations |
| **Transaction** | `storage/tx` | WAL-based transaction support |
| **Record** | `storage/record` | Binary serialization/deserialization |
| **Buffer** | `storage/buffer` | In-memory page caching with LRU |
| **Page** | `storage/page` | Slotted page format |
| **File** | `storage/file` | Low-level disk I/O |

---

## 📈 Data Flow Summary

### Write Path
```
Application → Engine → Executor → WAL (durability) → Catalog 
            → Table (find page) → Record (serialize) → Buffer Pool 
            → Page (format) → Disk Manager (persist)
```

### Read Path
```
Application → Engine → Executor → Catalog → Table/Index 
            → Buffer Pool (fetch) → Page (get slot) 
            → Record (deserialize) → Application
```

### Prepared Statement Flow
```
Application → Prepare(sql) → Parse placeholders → Store template
            → Execute(args) → Bind parameters → Sanitize values 
            → Execute SQL → Return result
```

---

## ✅ Supported SQL Features

| Feature | Status | Example |
|---------|--------|---------|
| CREATE TABLE | ✅ | `CREATE TABLE t (id INTEGER, name TEXT)` |
| DROP TABLE | ✅ | `DROP TABLE t` |
| INSERT | ✅ | `INSERT INTO t VALUES (1, 'a')` |
| SELECT | ✅ | `SELECT * FROM t WHERE id = 1` |
| UPDATE | ✅ | `UPDATE t SET x = x + 1 WHERE id = 1` |
| DELETE | ✅ | `DELETE FROM t WHERE id = 1` |
| JOIN | ✅ | `SELECT * FROM a INNER JOIN b ON a.id = b.id` |
| LEFT JOIN | ✅ | `SELECT * FROM a LEFT JOIN b ON a.id = b.id` |
| Aggregates | ✅ | `COUNT, SUM, AVG, MIN, MAX` |
| GROUP BY | ✅ | `SELECT dept, COUNT(*) FROM emp GROUP BY dept` |
| ORDER BY | ✅ | `SELECT * FROM t ORDER BY name DESC` |
| LIMIT | ✅ | `SELECT * FROM t LIMIT 10` |
| Aliases | ✅ | `SELECT t.id AS tid FROM table t` |
| Transactions | ✅ | `BEGIN; ... COMMIT; / ROLLBACK;` |
| NULL values | ✅ | `INSERT INTO t VALUES (1, NULL)` |
| Prepared Stmt | ✅ | `db.Prepare("SELECT * FROM t WHERE id = ?")` |

---

*CitrineDB - A lightweight embedded SQL database written in Go*
